package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/github/github-mcp-server/internal/ghmcp\"\n\t\"github.com/github/github-mcp-server/pkg/github\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\n// These variables are set by the build process using ldflags.\nvar version = \"version\"\nvar commit = \"commit\"\nvar date = \"date\"\n\nvar (\n\trootCmd = &cobra.Command{\n\t\tUse:     \"server\",\n\t\tShort:   \"GitHub MCP Server\",\n\t\tLong:    `A GitHub MCP server that handles various tools and resources.`,\n\t\tVersion: fmt.Sprintf(\"Version: %s\\nCommit: %s\\nBuild Date: %s\", version, commit, date),\n\t}\n\n\tstdioCmd = &cobra.Command{\n\t\tUse:   \"stdio\",\n\t\tShort: \"Start stdio server\",\n\t\tLong:  `Start a server that communicates via standard input/output streams using JSON-RPC messages.`,\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\ttoken := viper.GetString(\"personal_access_token\")\n\t\t\tif token == \"\" {\n\t\t\t\treturn errors.New(\"GITHUB_PERSONAL_ACCESS_TOKEN not set\")\n\t\t\t}\n\n\t\t\t// If you're wondering why we're not using viper.GetStringSlice(\"toolsets\"),\n\t\t\t// it's because viper doesn't handle comma-separated values correctly for env\n\t\t\t// vars when using GetStringSlice.\n\t\t\t// https://github.com/spf13/viper/issues/380\n\t\t\tvar enabledToolsets []string\n\t\t\tif err := viper.UnmarshalKey(\"toolsets\", &enabledToolsets); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal toolsets: %w\", err)\n\t\t\t}\n\n\t\t\tstdioServerConfig := ghmcp.StdioServerConfig{\n\t\t\t\tVersion:              version,\n\t\t\t\tHost:                 viper.GetString(\"host\"),\n\t\t\t\tToken:                token,\n\t\t\t\tEnabledToolsets:      enabledToolsets,\n\t\t\t\tDynamicToolsets:      viper.GetBool(\"dynamic_toolsets\"),\n\t\t\t\tReadOnly:             viper.GetBool(\"read-only\"),\n\t\t\t\tExportTranslations:   viper.GetBool(\"export-translations\"),\n\t\t\t\tEnableCommandLogging: viper.GetBool(\"enable-command-logging\"),\n\t\t\t\tLogFilePath:          viper.GetString(\"log-file\"),\n\t\t\t}\n\n\t\t\treturn ghmcp.RunStdioServer(stdioServerConfig)\n\t\t},\n\t}\n)\n\nfunc init() {\n\tcobra.OnInitialize(initConfig)\n\n\trootCmd.SetVersionTemplate(\"{{.Short}}\\n{{.Version}}\\n\")\n\n\t// Add global flags that will be shared by all commands\n\trootCmd.PersistentFlags().StringSlice(\"toolsets\", github.DefaultTools, \"An optional comma separated list of groups of tools to allow, defaults to enabling all\")\n\trootCmd.PersistentFlags().Bool(\"dynamic-toolsets\", false, \"Enable dynamic toolsets\")\n\trootCmd.PersistentFlags().Bool(\"read-only\", false, \"Restrict the server to read-only operations\")\n\trootCmd.PersistentFlags().String(\"log-file\", \"\", \"Path to log file\")\n\trootCmd.PersistentFlags().Bool(\"enable-command-logging\", false, \"When enabled, the server will log all command requests and responses to the log file\")\n\trootCmd.PersistentFlags().Bool(\"export-translations\", false, \"Save translations to a JSON file\")\n\trootCmd.PersistentFlags().String(\"gh-host\", \"\", \"Specify the GitHub hostname (for GitHub Enterprise etc.)\")\n\n\t// Bind flag to viper\n\t_ = viper.BindPFlag(\"toolsets\", rootCmd.PersistentFlags().Lookup(\"toolsets\"))\n\t_ = viper.BindPFlag(\"dynamic_toolsets\", rootCmd.PersistentFlags().Lookup(\"dynamic-toolsets\"))\n\t_ = viper.BindPFlag(\"read-only\", rootCmd.PersistentFlags().Lookup(\"read-only\"))\n\t_ = viper.BindPFlag(\"log-file\", rootCmd.PersistentFlags().Lookup(\"log-file\"))\n\t_ = viper.BindPFlag(\"enable-command-logging\", rootCmd.PersistentFlags().Lookup(\"enable-command-logging\"))\n\t_ = viper.BindPFlag(\"export-translations\", rootCmd.PersistentFlags().Lookup(\"export-translations\"))\n\t_ = viper.BindPFlag(\"host\", rootCmd.PersistentFlags().Lookup(\"gh-host\"))\n\n\t// Add subcommands\n\trootCmd.AddCommand(stdioCmd)\n}\n\nfunc initConfig() {\n\t// Initialize Viper configuration\n\tviper.SetEnvPrefix(\"github\")\n\tviper.AutomaticEnv()\n}\n\nfunc main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}"